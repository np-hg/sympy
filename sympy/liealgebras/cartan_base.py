from sympy.core.function import ArgumentIndexError
from sympy.utilities.codegen import Argument
from sympy.utilities.iterables import flatten
from sympy.matrices.dense import MutableDenseMatrix
from sympy.core import Basic
from sympy.matrices import zeros, Matrix, eye, ones
from sympy.core.sympify import _sympify

def list2matrix(func):
    def checkmat(x):
        if isinstance(x, list):
            x = Matrix(x)
            if x.shape[-1] == 1:
                x = x.T
        return x
    def wrapper(*args, **kwargs):
        wargs = []
        for arg in args:
            arg = checkmat(arg)
            wargs.append(arg)
        wkwargs = {}
        for k,v in kwargs.items():
            v = checkmat(v)
            kwargs[k]=v
        return func(*wargs, **wkwargs)
    return wrapper

class Standard_Cartan(Basic):
    """
    Semi-Concrete base class for Cartan types such as A4, etc. In this module we make
    certain choices about how to represent the algebra.  This class is never meant to be
    called directly. It is exported as `CartanType` and should be called that way.

    Examples
    ========
    >>> from sympy.liealgebras import CartanType
    >>> CartanType("G2")
    TypeG('G', 2)

    Sources
    =======
    - https://inspirehep.net/literature/181168
    - https://www.researchgate.net/publication/252487471_Group_Theory_A_Physicist's_Survey
    - https://arxiv.org/pdf/1206.6379.pdf
    """

    def __new__(cls, series, n):
        n= _sympify(n)
        return super().__new__(cls, series, n)

    @property
    def rank(self):
        """
        Returns the rank of the Lie algebra
        """
        return self.args[1]

    @property
    def series(self):
        """
        Returns the type of the Lie algebra
        """
        return self.args[0]

    def cartan_matrix(self):
        r"""
        Returns the Cartan Matrix for the algebra. For a
        given simple Lie algebra the elements $a_{ij}$ can be
        generated by

        .. math::
            a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle

        where $a_i$ is the i'th simple root and $\langle,\rangle$ is the scalar product.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Cartan_matrix
        - https://mathworld.wolfram.com/CartanMatrix.html

        """
        if hasattr(self, "_cartan_matrix"):
            return self._cartan_matrix
        r = self.rank
        cartan_matrix = zeros(r,r)
        for i, sr_i in enumerate(self.simple_roots()):
            for j, sr_j in enumerate(self.simple_roots()):
                cartan_matrix[j,i] = 2 * sr_i.dot(sr_j) / sr_i.dot(sr_i)
        self._cartan_matrix = cartan_matrix
        return self._cartan_matrix

    def cocartan_matrix(self):
        r"""
        Returns the Cocartan matrix. The Cocartan matrix
        row elements, $c_i$, are built from covectors of simple roots, $\alpha_i$.

        .. math::
            c_i = 2 \alpha_i / \langle \alpha_i, \alpha_i \rangle

        This relationship is helpful in defining the orthogonal base where
        multiplying by some weight, $w_j$, yields the unit matrix.

        .. math::
            \langle c_i, w_j \rangle = \delta_{ij}

        """
        if hasattr(self, "_cocartan_matrix"):
            return self._cocartan_matrix
        self._cocartan_matrix = Matrix([
                2 * x / x.dot(x) for x in self.simple_roots()])
        return self._cocartan_matrix

    def omega_matrix(self):
        """
        Returns the omega matrix whose rows are built from
        the fundamental weights of the algebra in the orthogonal
        basis.
        """
        if hasattr(self, "_omega_matrix"):
            return self._omega_matrix
        self._omega_matrix = self.cocartan_matrix().pinv().T
        return self._omega_matrix

    def simple_root(self, i):
        """
        Returns the i'th simple root in the orthogonal basis.
        """
        raise NotImplementedError("Do not call this method directly from the base class.")
    
    # explicit return annotation to help pylance users
    def simple_roots(self) -> list:
        """
        Returns the simple roots of the algebra.
        """
        return [Matrix(self.simple_root(i+1)) for i in range(self.rank)]

    def fundamental_weight(self, i):
        r"""
        Returns the i'th fundamental weight of the algebra in the
        orthogonal basis.

        Note: To match consistency with simple roots, i starts at 1.

        Explanation
        ===========
        The weights of an algebra, lambda, can be
        written as a linear combination of the simple roots, $\alpha_i$.
        The following theorem,

        .. math::
            a_i = 2\langle\lambda, \alpha_i \rangle / \langle\alpha_i, \alpha_i \rangle


        where $a_i$ are the Dynkin labels.  The fundamental weights
        of the algebra are the weights, lambda, with the smallest $a_i >= 0$.
        Note that if $\lambda_i==\alpha_i$, then the Dynkin labels become
        the elements of the Cartan matrix.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Weight_(representation_theory)
        - http://www.math.columbia.edu/~woit/notes11.pdf
        """
        i = i - 1
        return self.omega_matrix().row(i)

    def fundamental_weights(self):
        """
        Returns a list of the fundamental weights in the orthogonal basis
        """
        return [self.fundamental_weight(i) for i in range(self.omega_matrix().rows)]

    def rootsystem(self):
        """Returns the root system of the group ordered from
        highest root to lowest. The roots are found by reflecting
        each simple root about its hyperplane, repeating this procedure
        on each subsequent root generated until no more are found.
        The roots are then weighed and sorted according to weight.

        Note: This is a costly calculation for groups with
        rank > 6, most notably E7 and E8

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> CartanType("A2").rootsystem()
        [Matrix([[1, 0, -1]]),
        Matrix([[0, 1, -1]]),
        Matrix([[1, -1, 0]]),
        Matrix([[0, 0, 0]]),
        Matrix([[0, 0, 0]]),
        Matrix([[-1, 1, 0]]),
        Matrix([[0, -1, 1]]),
        Matrix([[-1, 0, 1]])]
        """
        s_r = self.simple_roots()
        rank = self.rank

        orbits = set()
        for i in s_r:
            for r in self.orbit(i):
                orbits.add(tuple(r))

        zero_roots = [zeros(1, rank)] * rank

        orbits = [Matrix([[*i]]) * self.cocartan_matrix().T for i in orbits] + zero_roots

        # sort roots by their weights
        orbits_by_level = {}
        for orb in orbits:
            level = -self.root_level(orb, 'alpha')
            current = orbits_by_level.get(level,[])
            current.append(orb)
            orbits_by_level[level] = current

        sorbits = []
        for level in sorted(orbits_by_level.keys()):
            sorbits += sorted(orbits_by_level[level], key=lambda x: tuple(x))

        # rotate back to the orthogonal basis for consistency
        omega_matrix = self.omega_matrix()
        return [x * omega_matrix for x in sorbits]

    def roots(self) -> Matrix:
        """Returns the number of total roots in the algebra"""
        raise NotImplementedError("Do not call this method directly from the base class.")

    
    def root_level(self, root, basis='orthogonal'):
        """Returns the root level of the root. The root level is calculated
        by rotating by the omega matrix and then summing the rotated vector.
        The basis argument flags which basis the incoming root or weight is in.
        This class's default basis is 'orthogonal' but when this method is called
        in the rootsystem calculations, the weights are passed via the 'alpha'
        basis.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> g2 = CartanType("G2")
        >>> rs = g2.rootsystem()
        >>> g2.root_level(rs[0])
        5
        """

        try:
            self._cached_r
        except AttributeError:
            inverse_cartan = self.cartan_matrix().pinv()
            self._cached_r = inverse_cartan * ones(inverse_cartan.rows, 1)

        r = self._cached_r

        if basis == 'orthogonal':
            root = root * self.omega_matrix().pinv()

        return (root * r)[0]

    def positive_roots(self):
        """Returns the set of all positive roots that are
        """
        if hasattr(self, "_positive_roots"):
            return self._positive_roots
        n_pos = self.roots() // 2
        self._positive_roots = self.rootsystem()[:n_pos]
        return self._positive_roots

    def orbit(self, head, stabilizer=None, basis="orthogonal"):
        """
        Returns the orbit of the weight or root by reflecting it
        a plane. A stabilizer may be passed to calculate the orbit using
        the Orbit-Stabilizer theorem.

        Note the stabilizer starts counting simple roots at index 0

        Sources
        =======
        - https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit
        - https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers
        """
        simple_roots = self.simple_roots()


        if isinstance(head, MutableDenseMatrix):
            head = head.as_immutable()

        head = self.to_orthogonal(head, basis)

        master_list = [head]
        master_hash = set([tuple(head)])

        if stabilizer:
            reflect_loop = [simple_roots[i] for i in stabilizer]
        else:
            reflect_loop = simple_roots

        # reflecting about a hyperplane
        reflection_matrix = lambda v: eye(len(v)) - 2 * v.T * v / v.dot(v)

        # Fill up master list of reflected roots by
        # continually operating on them until all weights in orbit are found

        # Duplicating each vector as a tuple to allow
        # for hasing them. This increases performance on
        # the large groups (rank > 6)

        if not hasattr(self, "_matrix_hash"):
            self._matrix_hash = {}

        while True:
            ref_list = []
            ref_list_hash = set()

            for w in master_list:
                for r in reflect_loop:
                    r_hash = tuple(r)

                    x = self._matrix_hash.get(r_hash)
                    if x:
                        r_m = x
                    else:
                        r_m = reflection_matrix(r)
                        self._matrix_hash[r_hash] = r_m

                    reflected = (r_m * w.T).T
                    reflected_hashable = tuple(reflected)
                    if reflected_hashable not in ref_list_hash and reflected_hashable not in master_hash:
                        ref_list.append(reflected)
                        ref_list_hash.add(reflected_hashable)
            if len(ref_list) == 0:
                break

            master_list += ref_list
            master_hash.update(ref_list_hash)
        return sorted((self.basis_transform(x,"orthogonal", basis) for x in master_list), key=tuple)

    def quadratic_form(self):
        r"""Returns the metric tensor of the algebra. Because of 
        usefulness in calculations, it is returned in the omega basis.

        Metric tensor in orthogonal basis is

        .. math::
            D_{ii} = \langle \alpha_i, \alpha_i \rangle / 2


        while returning it in the omega basis is

        .. math::
            D' = A^{-1} D


        where $A$ is the cartan matrix.

        """

        if hasattr(self, "_quadratic_form"):
            return self._quadratic_form
        quadratic_form = zeros(self.rank)
        sr = self.simple_roots()
        for i in range(self.rank):
            quadratic_form[i,i] = sr[i].dot(sr[i]) / 2
        self._quadratic_form = self.cartan_matrix().pinv() * quadratic_form
        return self._quadratic_form

    @list2matrix
    def basis_transform(self, weight, basis_in, basis_out):
        """Transforms a `weight` from `basis_in` to `basis_out`.
        Basis must be in {"orthogonal", "omega", "alpha"}.
        """
        
        if basis_out == "orthogonal":
            return self.to_orthogonal(weight, basis_in)
        if basis_out == "omega":
            return self.to_omega(weight, basis_in)
        if basis_out == "alpha":
            return self.to_alpha(weight, basis_in)
        raise KeyError("Lie basis not found")

    @list2matrix
    def to_orthogonal(self, weight, basis):
        """Returns the `weight` in the orthogonal basis from the current
        `basis`. The orthogonal basis is the basis where simple roots are 
        written in a Euclidean subspace.
        """
        is_row = weight.shape[0] == 1

        if not is_row:
            return self.to_orthogonal(weight.T, basis).T

        if basis == "orthogonal":
            return weight
        if basis == "alpha":
            return weight * self.cartan_matrix() * self.omega_matrix()
        if basis == "omega":
            return weight * self.omega_matrix()
        raise KeyError("Lie basis not found")

    @list2matrix
    def to_alpha(self, weight, basis):
        """Returns the `weight` in the alpha basis from the current
        `basis`. The alpha basis is the basis of the simple roots.
        """
        is_row = weight.shape[0] == 1

        if not is_row:
            return self.to_alpha(weight.T, basis).T

        if basis == "orthogonal":
            return weight * self.omega_matrix().pinv() * self.cartan_matrix().pinv()
        if basis == "alpha":
            return weight
        if basis == "omega":
            return weight * self.cartan_matrix().pinv()
        raise KeyError("Lie basis not found")
    
    @list2matrix
    def to_omega(self, weight, basis):
        """Returns the `weight` in the omega basis from the current
        `basis`. The omega basis is the basis where all simple roots
        are written as rows of the cartan matrix. Also called the
        Dynkin Basis. This is the basis of the fundamental weights."""

        is_row = weight.shape[0] == 1

        if not is_row:
            return self.to_omega(weight.T, basis).T

        if basis == "orthogonal":
            return weight * self.omega_matrix().pinv()
        if basis == "alpha":
            return weight * self.cartan_matrix() 
        if basis == "omega":
            return weight
        raise KeyError("Lie basis not found")
    
    @list2matrix
    def single_dominant_weights(self, irrep, basis="omega"):
        """Returns the single dominant weights of the irreducible representation"""
        def select_pos(irrep):
            pos = set()
            for pr in pr_omega:
                res = irrep - pr
                if all([x >=0 for x in res]):
                    pos.add(tuple(res))
            return pos

        def union_new_weights(irreps):
            res = set()
            for w in irreps:
                res = res.union(select_pos(w))
            return res

        irrep = self.to_omega(irrep, basis)
        pr_omega = [self.to_omega(x,"orthogonal") for x in self.positive_roots()]

        tower = [irrep]
        tower_set = set([tuple(irrep)])
        while True:
            temp = union_new_weights(tower)
            diff = temp.difference(tower_set)

            if len(diff) == 0:
                break
            
            for x in diff:
                tower.append(Matrix([[*x]]))
                tower_set.add(x)

        return sorted(tower, key=self.k_level)[::-1]

    @list2matrix
    def weight_multiplicity(self, weight, irrep, basis="omega"):
        """Returns the weight multiplicity in the irreducible representation"""
        irrep = self.to_omega(irrep, basis)
        dominant_weight, _ = self.chamber_rotate(weight, basis)
        dominant_irrep = self.single_dominant_weights(irrep)

        if irrep == dominant_weight:
            return 1
        # omega basis from here on
        k = int(self.k_level(irrep-weight, basis))

        # group the xi, weight(if it is dominant) and its multiplicity
        # by adding xi to it over and over. This is analagous to 
        # the ladder operator in quantum mechanics (actually this is where qm gets it from)
        highest_weights = []
        for i in range(k):
            for xi, mul in self.xi_multiplicity(dominant_weight):
                dom = dominant_weight + (i+1) * xi
                if dom in dominant_irrep:
                    highest_weights.append((dom, xi, mul))

        # Below is freudenthal's recursion formula
        multiplicity = 0
        rho = ones(1, self.rank)
        for (w, xi, m) in highest_weights:
            dom, _ = self.chamber_rotate(w)
            num = m * self.weight_multiplicity(dom, irrep) * self.scalar_product(w, xi)
            d1 = self.scalar_product(irrep + rho, irrep + rho)
            d2 = self.scalar_product(dominant_weight + rho, dominant_weight + rho)
            multiplicity += num / (d1-d2)
        return multiplicity

    @list2matrix
    def scalar_product(self, weight1, weight2, basis="omega"):
        """Returns the scalar product between to weights. If the incoming
        basis is orthogonal, it is a simple inner product. Otherwise
        it is done by taking the product by inserting
        a rotation by the quadratic form due to the lack of orthogonality."""
        if basis == "orthogonal":
            return weight1.dot(weight2)
        weight1 = self.to_omega(weight1, basis)
        weight2 = self.to_omega(weight2, basis) 
        return (weight1 * self.quadratic_form()).dot(weight2)

    @list2matrix
    def k_level(self, weight, basis="omega"):
        return sum(self.to_alpha(weight, basis))

    @list2matrix
    def chamber_rotate(self, weight, basis="omega"):
        """Returns the tuple of (dominant weight, parity) of weight the 
        into the dominant chamber using weyl reflections across the weyl chambers.
        """
        counter = 1
        weight = self.to_omega(weight, basis)
        if all([x >=0 for x in weight]):
            return weight, counter

        reflection_matrix = lambda v: eye(len(v)) - 2 * v.T * v / v.dot(v)
        reflected = weight
        
        reflected_ortho = self.to_orthogonal(weight, basis)

        while True:
            for sr in self.simple_roots():
                counter *= -1

                if reflected_ortho.shape[0] != 1:
                    reflected_ortho = reflected_ortho.T

                temp = reflected_ortho * reflection_matrix(sr)
                reflected = self.to_omega(temp, "orthogonal")
                reflected_ortho = temp

                if all([x >=0 for x in reflected]):
                    return reflected, counter

    @list2matrix
    def xi_multiplicity(self, weight, basis="omega"):
        """Returns a list of tuples that are the multiplicty and xi of 
        each the weight. 
        
        Xi is defined to be a member of the 
        positive roots where each coeffcient is positive
        nonzero. The multiplicity is the dimension of that
        xi's orbit.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> from sympy import Matrix
        >>> a4 = CartanType("A4")
        >>> a4.xi_multiplicity(Matrix([[0,1,0,0]]))
        [(Matrix([[1, 0, 0, 1]]), 12),
        (Matrix([[0, -1, 1, 1]]), 6),
        (Matrix([[2, -1, 0, 0]]), 2)]
        """
        weight = self.to_omega(weight, basis)

        # performance considerations
        if not hasattr(self, "_weight_multiplicity_cache"):
            self._weight_multiplicity_cache = {}

        cached_selection = self._weight_multiplicity_cache.get(tuple(weight))
        if cached_selection:
            return cached_selection

        xi_multiplicity = []
        stabs = set()

        # Find the stabilizers. np.argwhere(weight == 0)
        for idx, i in enumerate(weight):
            if i == 0:
                stabs.add(idx)

        # Unique representativeness of the orbit 
        # xis are the positive roots where weight has nonzero 
        # coeffecients.
        xis = []
        prs = [self.to_omega(x, "orthogonal") for x in self.positive_roots()]
        for pr in prs:
            if all([pr[i] >= 0 for i in stabs]):
                xis.append(pr)
        
        for xi in xis:
            xi_stab = set()
            temp = self.to_alpha(xi, "omega")
            for i in range(self.rank):
                if temp[i] > 0:
                    xi_stab.add(i)
            diff = xi_stab.difference(stabs)

            orbit = self.orbit(self.to_orthogonal(xi, "omega"), stabs)
            # length or orbit differs due to that if the stab is in the xis, then
            # the negative roots are included, thus we multiply the opposite case by 2
            if len(diff) == 0:
                xi_multiplicity.append((xi, len(orbit)))
            else:
                xi_multiplicity.append((xi, 2 * len(orbit)))
        
        # cache for use later, worth it in large ranked classes.
        self._weight_multiplicity_cache[tuple(weight)] = xi_multiplicity
        return xi_multiplicity


    @list2matrix
    def weight_system(self, irrep, basis="omega"):
        """Returns the entire weight system using the irrep as the highest weight and 
        subtracting down to the lowest weight of the representations"""
        irrep = self.to_omega(irrep, basis)
        dom_weight_system = [
            (x, self.weight_multiplicity(x, irrep)) for x in self.single_dominant_weights(irrep)]

        weight_system = []
        for weight, m in dom_weight_system:
            weight_system += [self.orbit(weight, basis="omega")] * m
        weight_system = flatten(weight_system, levels=1)
        return sorted(weight_system, key=lambda s: self.k_level(irrep - s))

    @list2matrix
    def dim(self, weight, basis="omega"):
        r"""Returns the dimension of the weight, root or irreducible representations.
        This follows Weyl's dimension formula:

        .. math::
            dim(w) = \prod_{\alpha\in\Delta^{+}} \frac{\langle \alpha, w + \rho\rangle}{\langle\alpha,\rho\rangle}

        where $\Delta^{+}$ are the positive roots and $rho$ is `[1,1,1,1...rank]`.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> from sympy import Matrix
        >>> a2 = CartanType("A2") # aka SU(3)
        >>> a2.dim(Matrix([[1,0]])) # fundamental rep
        3
        """

        # weight must be in omega basis while posroots are in alpha
        # as defined by the weyl formula
        weight = self.to_omega(weight, basis)
        rho = ones(1, self.rank)
        pr_omega = [self.to_omega(x,"orthogonal") for x in self.positive_roots()]

        dim = 1
        for root in pr_omega:
            numer = self.scalar_product(weight + rho, root)
            denom = self.scalar_product(rho, root)
            dim *= (numer / denom)
        return _sympify(dim)

    @list2matrix
    def _tensor_product_decomp(self, weight1, weight2, basis="omega"):
        def adjacent_find(it, func):
            for idx, i in enumerate(it):
                if idx + 1 >= len(it):
                    return
                if func(i) == func(it[idx+1]):
                    yield idx

        weight1 = self.to_omega(weight1, basis)
        weight2 = self.to_omega(weight2, basis)

        tower1 = self.weight_system(weight1) 
        rho = ones(1, self.rank)

        mu = [w + weight2 + rho for w in tower1]
        
        weight_parities = []
        for m in mu:
            t, parity = self.chamber_rotate(m)

            # drop weights lying on the weyl domain wall
            if not any([x==0 for x in t]):
                t -= rho
                weight_parities.append([parity, t])

        # sort by weight in omega basis
        weight_parities = sorted(weight_parities, key=lambda x: tuple(x[1]))
        
        for i in adjacent_find(weight_parities, lambda x: x[1]):
            weight_parities[i+1][0] += weight_parities[i][0]
            weight_parities[i][0] = 0

        tensor_product_decomp = []
        for m, w in weight_parities:
            tensor_product_decomp += [w]*m

        return tensor_product_decomp
        
    def tensor_product_decompose(self, *weights, basis="omega"):
        if len(weights) < 2:
            raise ValueError("Tensor product must have >2 weights")
        
        decomp = []
        N = len(weights)
        for i in range(N-1):
            decomp += self._tensor_product_decomp(weights[i], weights[i+1], basis)
        return decomp
