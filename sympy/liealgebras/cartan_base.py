from typing import List
from sympy.matrices.dense import MutableDenseMatrix
from sympy.core import Basic
from sympy.matrices import zeros, Matrix, eye, ones
from sympy.core.sympify import _sympify

class Standard_Cartan(Basic):
    """
    Semi-Concrete base class for Cartan types such as A4, etc. In this module we make
    certain choices about how to represent the algebra.  This class is never meant to be
    called directly. It is exported as `CartanType` and should be called that way.

    Examples
    ========
    >>> from sympy.liealgebras import CartanType
    >>> CartanType("G2")
    TypeG('G', 2)

    Sources
    =======
    - https://inspirehep.net/literature/181168
    - https://www.researchgate.net/publication/252487471_Group_Theory_A_Physicist's_Survey
    - https://arxiv.org/pdf/1206.6379.pdf
    """

    def __new__(cls, series, n):
        n= _sympify(n)
        return super().__new__(cls, series, n)

    @property
    def rank(self):
        """
        Returns the rank of the Lie algebra
        """
        return self.args[1]

    @property
    def series(self):
        """
        Returns the type of the Lie algebra
        """
        return self.args[0]

    def cartan_matrix(self):
        r"""
        Returns the Cartan Matrix for the algebra. For a
        given simple Lie algebra the elements $a_{ij}$ can be
        generated by

        .. math::
            a_{ji} = 2 \langle\alpha_i, \alpha_j\rangle / \langle\alpha_j, \alpha_j\rangle

        where $a_i$ is the i'th simple root and $\langle,\rangle$ is the scalar product.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Cartan_matrix
        - https://mathworld.wolfram.com/CartanMatrix.html

        """
        if hasattr(self, "_cartan_matrix"):
            return self._cartan_matrix
        r = self.rank
        cartan_matrix = zeros(r,r)
        for i, sr_i in enumerate(self.simple_roots()):
            for j, sr_j in enumerate(self.simple_roots()):
                cartan_matrix[j,i] = 2 * sr_i.dot(sr_j) / sr_i.dot(sr_i)
        self._cartan_matrix = cartan_matrix
        return self._cartan_matrix

    def cocartan_matrix(self):
        r"""
        Returns the Cocartan matrix. The Cocartan matrix
        row elements, $c_i$, are built from covectors of simple roots, $\alpha_i$.

        .. math::
            c_i = 2 \alpha_i / \langle \alpha_i, \alpha_i \rangle

        This relationship is helpful in defining the orthogonal base where
        multiplying by some weight, $w_j$, yields the unit matrix.

        .. math::
            \langle c_i, w_j \rangle = \delta_{ij}

        """
        if hasattr(self, "_cocartan_matrix"):
            return self._cocartan_matrix
        self._cocartan_matrix = Matrix([
                2 * x / x.dot(x) for x in self.simple_roots()])
        return self._cocartan_matrix

    def omega_matrix(self):
        """
        Returns the omega matrix, which rows are built from
        the fundamental weights of the algebra in the orthogonal
        basis.
        """
        if hasattr(self, "_omega_matrix"):
            return self._omega_matrix
        self._omega_matrix = self.cocartan_matrix().pinv().T
        return self._omega_matrix

    def simple_root(self, i):
        """
        Returns the i'th simple root in the orthogonal basis.
        """
        raise NotImplementedError("Do not call this method directly from the base class.")


    def simple_roots(self) -> List[Matrix]:
        """
        Returns the simple roots of the algebra.
        """
        return [Matrix(self.simple_root(i+1)) for i in range(self.rank)]

    def fundamental_weight(self, i):
        r"""
        Returns the i'th fundamental weight of the algebra in the
        orthogonal basis.

        Note: To match consistency with simple roots, i starts at 1.

        Explanation
        ===========
        The weights of an algebra, lambda, can be
        written as a linear combination of the simple roots, $\alpha_i$.
        The following theorem,

        .. math::
            a_i = 2\langle\lambda, \alpha_i \rangle / \langle\alpha_i, \alpha_i \rangle


        where $a_i$ are the Dynkin labels.  The fundamental weights
        of the algebra are the weights, lambda, with the smallest $a_i >= 0$.
        Note that if $\lambda_i==\alpha_i$, then the Dynkin labels become
        the elements of the Cartan matrix.

        Sources
        =======
        - https://en.wikipedia.org/wiki/Weight_(representation_theory)
        - http://www.math.columbia.edu/~woit/notes11.pdf
        """
        i = i - 1
        return self.omega_matrix().row(i)

    def fundamental_weights(self):
        """
        Returns a list of the fundamental weights in the orthogonal basis
        """
        return [self.fundamental_weight(i) for i in range(self.omega_matrix().rows)]

    def rootsystem(self):
        """Returns the root system of the group ordered from
        highest root to lowest. The roots are found by reflecting
        each simple root about its hyperplane, repeating this procedure
        on each subsequent root generated until no more are found.
        The roots are then weighed and sorted according to weight.

        Note: This is a costly calculation for groups with
        rank > 6, most notably E7 and E8

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> CartanType("A2").rootsystem()
        [Matrix([[1, 0, -1]]),
        Matrix([[0, 1, -1]]),
        Matrix([[1, -1, 0]]),
        Matrix([[0, 0, 0]]),
        Matrix([[0, 0, 0]]),
        Matrix([[-1, 1, 0]]),
        Matrix([[0, -1, 1]]),
        Matrix([[-1, 0, 1]])]
        """
        s_r = self.simple_roots()
        rank = self.rank

        orbits = set()
        for i in s_r:
            for r in self.orbit(i):
                orbits.add(tuple(r))

        zero_roots = [Matrix([0] * rank).T] * rank

        orbits = [Matrix([[*i]]) * self.cocartan_matrix().T for i in orbits] + zero_roots

        # sort roots by their weights
        orbits_by_level = {}
        for orb in orbits:
            level = -self.root_level(orb, 'alpha')
            current = orbits_by_level.get(level,[])
            current.append(orb)
            orbits_by_level[level] = current

        sorbits = []
        for level in sorted(orbits_by_level.keys()):
            sorbits += sorted(orbits_by_level[level], key=lambda x: tuple(x))

        # rotate back to the orthogonal basis for consistency
        omega_matrix = self.omega_matrix()
        return [x * omega_matrix for x in sorbits]

    def roots(self) -> Matrix:
        """Returns the number of total roots in the algebra"""
        raise NotImplementedError("Do not call this method directly from the base class.")

    def root_level(self, root, basis='orthogonal'):
        """Returns the root level of the root. The root level is calculated
        by rotating by the omega matrix and then summing the rotated vector.
        The basis argument flags which basis the incoming root or weight is in.
        This class's default basis is 'orthogonal' but when this method is called
        in the rootsystem calculations, the weights are passed via the 'alpha'
        basis.

        Examples
        ========
        >>> from sympy.liealgebras import CartanType
        >>> g2 = CartanType("G2")
        >>> rs = g2.rootsystem()
        >>> g2.root_level(rs[0])
        5
        """

        try:
            self._cached_r
        except AttributeError:
            inverse_cartan = self.cartan_matrix().pinv()
            self._cached_r = inverse_cartan * ones(inverse_cartan.rows, 1)

        r = self._cached_r

        if basis == 'orthogonal':
            root = root * self.omega_matrix().pinv()

        return (root * r)[0]

    def positive_roots(self):
        """Returns the set of all positive roots that are
        """
        if hasattr(self, "_positive_roots"):
            return self._positive_roots
        n_pos = self.roots() // 2
        self._positive_roots = self.rootsystem()[:n_pos]
        return self._positive_roots

    def orbit(self, head, stabilizer=None):
        """
        Returns the orbit of the weight or root by reflecting it
        a plane. A stabilizer may be passed to calculate the orbit using
        the Orbit-Stabilizer theorem.

        Note the stabilizer starts counting simple roots at index 0

        Sources
        =======
        - https://en.wikipedia.org/wiki/Coadjoint_representation#Coadjoint_orbit
        - https://en.wikipedia.org/wiki/Group_action#Orbits_and_stabilizers
        """
        simple_roots = self.simple_roots()

        if isinstance(head, MutableDenseMatrix):
            head = head.as_immutable()

        master_list = [head]
        master_hash = set([tuple(head)])

        if stabilizer:
            reflect_loop = [simple_roots[i] for i in stabilizer]
        else:
            reflect_loop = simple_roots

        # reflecting about a hyperplane
        reflection_matrix = lambda v: eye(len(v)) - 2 * v.T * v / v.dot(v)

        # Fill up master list of reflected roots by
        # continually operating on them until all weights in orbit are found

        # Duplicating each vector as a tuple to allow
        # for hasing them. This increases performance on
        # the large groups (rank > 6)
        matrix_hash = {}
        while True:
            ref_list = []
            ref_list_hash = set()

            for w in master_list:
                for r in reflect_loop:
                    r_hash = tuple(r)

                    x = matrix_hash.get(r_hash)
                    if x:
                        r_m = x
                    else:
                        r_m = reflection_matrix(r)
                        matrix_hash[r_hash] = r_m

                    reflected = (r_m * w.T).T
                    reflected_hashable = tuple(reflected)
                    if reflected_hashable not in ref_list_hash and reflected_hashable not in master_hash:
                        ref_list.append(reflected)
                        ref_list_hash.add(reflected_hashable)
            if len(ref_list) == 0:
                break

            master_list += ref_list
            master_hash.update(ref_list_hash)
        return master_list

    def quadratic_form(self):
        if hasattr(self, "_quadratic_form"):
            return self._quadratic_form
        quadratic_form = zeros(self.rank)
        sr = self.simple_roots()
        for i in range(self.rank):
            quadratic_form[i,i] = sr[i].dot(sr[i]) / 2
        self._quadratic_form = self.cartan_matrix().pinv() * quadratic_form
        return self._quadratic_form

    def to_ortho(self, weight, basis):
        if basis == "orthogonal":
            return weight
        if basis == "alpha":
            return self.omega_matrix().T * self.cartan_matrix().T * weight
        if basis == "omega":
            return weight*self.omega_matrix().T
        raise KeyError("Lie basis not found")

    def to_alpha(self, weight, basis):
        if basis == "orthogonal":
            return weight * self.omega_matrix().pinv() * self.cartan_matrix().pinv()
        if basis == "alpha":
            return weight
        if basis == "omega":
            return weight * self.cartan_matrix().pinv()
        raise KeyError("Lie basis not found")

    def to_omega(self, weight, basis):
        if basis == "orthogonal":
            return weight * self.omega_matrix().pinv()
        if basis == "alpha":
            return weight * self.cartan_matrix().T 
        if basis == "omega":
            return weight
        raise KeyError("Lie basis not found")
    
    def dominant_weights(self, weights, basis="omega"):
        dominant_weights = []
        for w in weights:
            w = self.to_omega(w, basis)
            if all([x >=0 for x in w]):
                dominant_weights.append(w)
        return dominant_weights

    def weight_tower(self, weight=None, basis="omega"):

        if weight is None:
            orbits = []
            for sr in self.simple_roots():
                orbits += self.orbit(sr)
            
            orbits = sorted(set([tuple(x) for x in orbits]))

            return [Matrix([[*x]]) for x in orbits] + \
                [Matrix([0] * self.rank).T] * self.rank

        tower = [self.to_omega(weight, basis)]
        sr = [self.to_omega(x, "orthogonal") for x in self.simple_roots()]

        for i in range(2 * self.k_level(tower[0]) + 1):
            for j in range(self.rank):
                p = 1
                while p <= tower[i][j]:
                    current = tower[i] - p * sr[j]
                    if current not in tower:
                        tower.append(current)
                    p+=1

        dominant_weights = self.dominant_weights(tower)

        weight_tower = []
        for w in dominant_weights:
            multiplicity = self.multiplicity(w)
            multi = self.freudenthals_recursion(w,  dominant_weights,  multiplicity)
            for i in range(multi):
                orbit = self.orbit(self.to_ortho(w, "omega"))
                weight_tower += orbit

        return weight_tower
        

    def k_level(self, weight, basis="omega"):
        return sum(self.to_alpha(weight, basis))

    def chamber_rotate(self, weight, counter, basis="omega"):
        
        weight = self.to_omega(weight, basis)
        if all([x >=0 for x in weight]):
            return weight, counter

        reflection_matrix = lambda v: eye(len(v)) - 2 * v.T * v / v.dot(v)

        reflected = weight
        max_loop = 0
        while max_loop < 10 ** self.rank:
            for sr in self.simple_roots():
                counter *= -1

                temp = reflection_matrix(sr) * self.to_ortho(reflected, "omega")
                reflected = self.to_omega(temp, "orthogonal")

                if all([x >=0 for x in reflected]):
                    return reflected, counter
            max_loop += 1

        raise  StopIteration("Max loop reached")
        
    def multiplicity(self, weight, basis="omega"):
        multiplicity = []
        stabs = set()

        weight = self.to_omega(weight, basis)

        for idx, i in enumerate(weight):
            if i == 0:
                stabs.add(idx)

        xis = []
        pr = [self.to_omega(x, "orthogonal") for x in self.positive_roots()]
        for pr in self.positive_roots():
            if all([x >= 0 for x in pr]):
                xis.append(pr)
        
        for xi in xis:
            xi_stab = set()
            temp = self.to_alpha(xi, "omega")
            for i in range(self.rank):
                if temp[i] > 0:
                    xi_stab.add(i)
            diff = xi_stab.difference(stabs)

            orbit = self.orbit(self.to_ortho(xi, "omega"), stabs)
            if len(diff) == 0:
                multiplicity.append((len(orbit), xi))
            else:
                multiplicity.append((2 * len(orbit), xi))
            
        return multiplicity

    def freudenthals_recursion(self, weight, dominant_weights, stabilized_orbits, basis="omega"):
        
        highest_weight = dominant_weights[0]
        k_current = self.k_level(weight, basis)
        k_highest = self.k_level(weight, basis)

        if weight == highest_weight:
            return 1

        dominant_weights = [self.to_omega(x, basis) for x in dominant_weights]
        weight = self.to_omega(weight, basis)
        stabilized_orbits = [self.to_omega(x, basis) for x in stabilized_orbits]

        dummy = 0
        k = 1
        s = 1

        while True:
            for stab in stabilized_orbits:
                next_w = weight + k * stab[1]
                rotated, dummy = self.chamber_rotate(next_w, dummy, "omega")
                if rotated not in dominant_weights:
                    inner = rotated.T * self.quadratic_form() * stab[1]
                    s += inner * self.freudenthals_recursion(rotated, dominant_weights, self.multiplicity(rotated, "omega")) * stab[0]
            k += 1
            if k >= (k_highest - k_current):
                break
        rho = Matrix([[1] * self.rank])
        d1 = (highest_weight + rho).T * self.quadratic_form() * (highest_weight + rho)
        d2 = (weight + rho).T * self.quadratic_form() * (weight + rho)

        return s / (d1 - d2)
